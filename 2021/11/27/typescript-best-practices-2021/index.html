<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Typescript 的最佳实践 2021 版 · 夜色镇歌</title><meta name="description" content="Typescript 的最佳实践 2021 版 - 文鹏飞"><meta name="baidu_union_verify" content="72cef2f38e5e048b980ace9972697c53"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://catwen.cn/atom.xml" title="夜色镇歌"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/333241589" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/wenpengfei" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Typescript 的最佳实践 2021 版</h1><div class="post-info">2021年11月27日</div><div class="post-content"><p>现在我们越来越多的项目都用上了 Typescript，也享受到了它带来的好处，为了更高效的使用它，我们可以遵循一些 <code>最佳实践</code>  ，以下的原则是我在使用并且推荐的</p>
<h2 id="使用正确的类型声明（避免使用-any-）"><a href="#使用正确的类型声明（避免使用-any-）" class="headerlink" title="使用正确的类型声明（避免使用 any ）"></a>使用正确的类型声明（避免使用 any ）</h2><p>类型声明是 Typescript 的一大优势，尤其是体现在代码编写阶段，因为 JavaScript 是在运行时定义类型的，Typescript 可以帮助你在运行之前就过滤掉一大部分类型引发的奇怪问题，当你知道你定义的变量是什么类型的时候不要使用 <code>any</code>，建议每次定义新变量的时候后都加上数据类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br><span class="line">value: <span class="built_in">number</span> = <span class="number">50</span>;</span><br><span class="line">isCorrect: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h2><p><code>use strict</code> 是 JavaScript ES5 添加的功能，它就是字面的意思：<code>使用严格模式</code>，可以在 <code>tsconfig</code> 文件中找到相关的配置。</p>
<p><img src="/images/typescript-best-practices-2021/1.png" alt="Untitled"></p>
<p>这样可以防止你犯无意识或低级的错误，例如使用未声明的变量、不使用类型注释或尝试使用未来的保留关键字作为变量名等。<code>use strict</code> 通过<code>语法错误</code>的形式帮助您编写良好且安全的代码习惯。</p>
<h2 id="使用-let-代替-var"><a href="#使用-let-代替-var" class="headerlink" title="使用 let 代替 var"></a>使用 let 代替 var</h2><p><em>var</em> 是一位很好的老朋友，但是 <em>let</em> 和 <em>const</em> 在 <em>ES6</em> 中出现了，他们的出现是为了解决 <em>var</em> 的一些问题。</p>
<p><em>var</em> 既可以作用于<code>全局作用域</code>又可以作用于<code>局部作用域</code>。</p>
<ul>
<li>当 <em>var</em> 类型变量在函数/块之外定义时，它就成为全局范围的变量，该变量可用于脚本内的任何地方</li>
<li>当 <em>var</em> 在函数内部定义时变为局部作用域，它只能在该函数内部访问</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name= <span class="string">"John Doe"</span>; <span class="comment">// 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age= <span class="number">30</span>; <span class="comment">// 局部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>var</em> 关键字有几个缺陷：可以重复声明，不声明也可以被调用，TS 也不会报错，会导致一些奇怪的问题。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"John Doe"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Anne"</span>; <span class="comment">// 不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为避免这种情况，应该改用 <em>let</em> 。 <em>let</em> 声明的是一个块级作用域变量，并且不能重新声明。但是你可以在不同的作用域中声明相同的变量名，每一个都被视为不同变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Anne"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// "Anne"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "John"</span></span><br></pre></td></tr></table></figure>
<h2 id="常量使用-const-声明"><a href="#常量使用-const-声明" class="headerlink" title="常量使用 const 声明"></a>常量使用 <strong>const 声明</strong></h2><p><em>const</em> 和 <em>let 是一起新增的变量声明</em>。 <em>const</em> 也是块级作用域类型，同样的，也不能被重新声明。这些是 <em>let</em> 和 <em>const</em> 之间的相似之处。不同之处是 <em>const</em> 不能被重新赋值。所以当你声明一个常量时使用 <em>const</em>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"John"</span>;</span><br><span class="line">name = <span class="string">"Anne"</span>; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">31</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：声明一个 <em>const</em> 对象时，不能重新对它赋值，但是可以修改它的的属性</p>
</blockquote>
<h2 id="固定长度的数组使用元组类型"><a href="#固定长度的数组使用元组类型" class="headerlink" title="固定长度的数组使用元组类型"></a>固定长度的数组使用元组类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> marks: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>你可以对 <code>marks</code> 数组添加任意数量的元素，只要都是 <code>number</code> 类型，TS 不会限制你。</p>
<p>但是，在数组长度为常量的情况下可能会导致严重的逻辑错误。为了避免这种错误，你可以使用元组类型来限制数组的长度和每一项的数据类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> marks:[<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 含有 2 个 number 类型元素的数组类型</span></span><br><span class="line">marks = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// 成功</span></span><br><span class="line">marks = [<span class="number">1</span>]; <span class="comment">// 语法错误</span></span><br><span class="line">marks = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// 语法错误</span></span><br></pre></td></tr></table></figure>
<h2 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h2><p>假设有多个变量或对象拥有相同的数据结构类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> man: &#123;name: <span class="built_in">string</span>, age: <span class="built_in">number</span>&#125; = &#123;name = <span class="string">"john"</span>, age=<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> woman: &#123;name: <span class="built_in">string</span>, age: <span class="built_in">number</span>&#125; = &#123;name = <span class="string">"Anne"</span>, age=<span class="number">32</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免这种冗余的类型定义你可以使用<code>类型别名</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Details = &#123;name: <span class="built_in">string</span>, age: <span class="built_in">number</span>&#125;; <span class="comment">// 定义类型别名</span></span><br><span class="line"><span class="keyword">let</span> man: Details = &#123;name = <span class="string">"john"</span>, age=<span class="number">30</span>&#125;; <span class="comment">// 使用类型别名</span></span><br><span class="line"><span class="keyword">let</span> woman: Details = &#123;name = <span class="string">"Anne"</span>, age=<span class="number">32</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>带来的额外好处就是代码的可读性更强，看起来更清晰</p>
<h2 id="any-和-unknown"><a href="#any-和-unknown" class="headerlink" title="any 和 unknown"></a>any 和 unknown</h2><p>表面上看来 <em>any</em>  和 <em>unknow</em> 没有什么区别，都是在我们不能确定数据类型的时候所使用的帮助类型，如果我们想快速的把 js 重构为 ts，两者均可，但是也有一些区别</p>
<p>任何值都可以标记为 <em>any</em>  或者 <em>unknown</em></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyExample: <span class="built_in">any</span>; <span class="comment">// 定义一个 any 类型</span></span><br><span class="line"><span class="keyword">let</span> unknownExample: unknown; <span class="comment">// 定义一个 unknown 类型</span></span><br><span class="line">anyExample = <span class="number">123</span>; </span><br><span class="line">anyExample = <span class="string">"Hey"</span></span><br><span class="line">unknownExample = <span class="literal">false</span>;</span><br><span class="line">unknownExample = <span class="number">23.22</span>;</span><br></pre></td></tr></table></figure>
<p>对于标记 any 的值，你可以对它做任何事</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anyExample.you.made.this.code.chain(); <span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<p>unknow 则不行，它是一种更安全的类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unknownExample.trim(); <span class="comment">// 语法错误</span></span><br></pre></td></tr></table></figure>
<p>如果要使用 <em>unknow</em> 类型，你得把他放在一个条件判断语句中</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exampleUnkown == <span class="string">"string"</span>) &#123; <span class="comment">// 第一步，检查类型</span></span><br><span class="line">  exampleUnkown.trim(); <span class="comment">// 不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对类成员使用访问修饰符"><a href="#对类成员使用访问修饰符" class="headerlink" title="对类成员使用访问修饰符"></a>对类成员使用访问修饰符</h2><p>TS 为 <em>class</em> 成员提供了<code>访问修饰符</code>，可以设置 <em>public</em>、<em>protected</em> 或者 <em>private</em> 属性，但 <em>class</em> 永远是 <code>public</code> 类型</p>
<ul>
<li>private：仅可以在内部访问</li>
<li>protected：内部或者子类可以访问</li>
<li>public：都可以访问</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> salary: <span class="built_in">number</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, salary: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getSalary()&#123;</span><br><span class="line">    <span class="keyword">return</span> salary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要访问 <code>salary</code> 属性，你必须调用 <code>getSalary</code> 方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Employee&#123;</span><br><span class="line">  viewDetails()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.salary); <span class="comment">// 错误: 属性 'salary' 是私有属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.getSalary()); <span class="comment">// success</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过子类访问 <code>name</code> 属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Employee&#123;</span><br><span class="line">  viewDetails()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Lint-工具"><a href="#使用-Lint-工具" class="headerlink" title="使用 Lint 工具"></a>使用 Lint 工具</h2><p>每个人都有自己的开发风格和习惯，在团队项目中，多种代码风格是灾难性的，如果不想污染代码库，还是需要选择一个 Lint 工具，首选 <code>ESLint</code>，它与 JavaScript 和 Typescript 都兼容</p>
<h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><p>使用好的代码格式化程序可以使您的编码更高效、更简洁。根据我的个人经验，我更喜欢在 VS 代码中使用 <code>Prettier</code>。但是有很多代码格式化程序，选择取决于你使用的编辑器</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/11/21/computer-hardware/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://catwen.cn">文鹏飞</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script data-ad-client="ca-pub-9719602535480843" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?508f12c140e77c01b9acd8055bcea5e2";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></body></html>