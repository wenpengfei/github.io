<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 创建一个离线优先，数据驱动的渐进式 Web 应用程序 · 夜色镇歌</title><meta name="description" content="创建一个离线优先，数据驱动的渐进式 Web 应用程序 - 文鹏飞"><meta name="baidu_union_verify" content="72cef2f38e5e048b980ace9972697c53"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.catwen.cn/atom.xml" title="夜色镇歌"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/333241589" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/wenpengfei" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">创建一个离线优先，数据驱动的渐进式 Web 应用程序</h1><div class="post-info">2018年1月30日</div><div class="post-content"><p><img src="/images/build-an-offline-first-data-driven-pwa/2.png" alt="img"></p>
<blockquote>
<p>原文地址：<a href="https://codelabs.developers.google.com/codelabs/workbox-indexeddb/index.html?index=..%2F..%2Findex#0" target="_blank" rel="noopener">Build an offline-first, data-driven PWA</a><br>译文出自：<a href="/2018/01/30/build-an-offline-first-data-driven-pwa/" title="夜色镇歌的个人博客">夜色镇歌的个人博客</a></p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在本文中，您将学习如何使用 Workbox 和 IndexedDB 创建离线优先、数据驱动的渐进式Web应用程序（PWA）。在离线的情况下也可以使用后台同步功能将应用程序与服务器同步。</p>
<h2 id="将会学习到"><a href="#将会学习到" class="headerlink" title="将会学习到"></a>将会学习到</h2><ul>
<li>如何使用 Workbox 缓存应用程序</li>
<li>如何使用 IndexedDB 存储数据</li>
<li>如何在用户脱机时从 IndexedDB 中检索和显示数据</li>
<li>脱机时如何保存数据</li>
<li>如何在脱机时使用后台同步更新应用程序</li>
</ul>
<h2 id="应该了解的"><a href="#应该了解的" class="headerlink" title="应该了解的"></a>应该了解的</h2><ul>
<li>HTML, CSS, 和 JavaScript</li>
<li>ES2015 Promises</li>
<li>如何使用命令行</li>
<li>熟悉一下 Workbox </li>
<li>熟悉一下 Gulp </li>
<li>熟悉一下 IndexedDB</li>
</ul>
<h2 id="需具备的条件"><a href="#需具备的条件" class="headerlink" title="需具备的条件"></a>需具备的条件</h2><ul>
<li>拥有 terminal/shell 访问权限的电脑</li>
<li>Chrome 52 或更高版本</li>
<li>编辑器</li>
<li>Nodejs 和 npm</li>
</ul>
<h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>如果你没有安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a> 需要安装一下</p>
<p>之后通过下面的方式 clone 快速启动仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/googlecodelabs/workbox-indexeddb.git</span><br></pre></td></tr></table></figure>
<p>或者直接下载 <a href="https://github.com/googlecodelabs/workbox-indexeddb/archive/master.zip" target="_blank" rel="noopener">压缩包</a></p>
<h1 id="安装依赖并启动服务"><a href="#安装依赖并启动服务" class="headerlink" title="安装依赖并启动服务"></a>安装依赖并启动服务</h1><p>到下载好的 git 仓库目录中，转到 <code>project</code> 文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> workbox-indexeddb/project/</span><br></pre></td></tr></table></figure>
<p>然后安装依赖并启动服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>这个步骤中会根据 <code>package.json</code> 定义的依赖并安装，打开 <code>package.json</code> 文件查看，有很多依赖，大部分是开发环境需要的（你可以忽略），主要的依赖是：</p>
<ul>
<li><a href="https://workboxjs.org/reference-docs/latest/module-workbox-sw.html" target="_blank" rel="noopener">workbox-sw</a> Workbox</li>
<li><a href="https://workboxjs.org/reference-docs/latest/module-workbox-background-sync.html" target="_blank" rel="noopener">workbox-background-sync</a> 是 Workbox 用来后台同步的，稍后会提到</li>
<li><a href="https://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 和 <a href="https://workboxjs.org/reference-docs/latest/module-workbox-build.html" target="_blank" rel="noopener">workbox-build</a> 是构建工具</li>
</ul>
<p><code>npm start</code> 会构建并输出到 <code>build</code> 文件夹，启动 dev server，并且会开启一个 <code>gulp watch</code> 任务。<code>gulp watch</code> 会监听文件的修改自动构建。<code>concurrently</code> 可以同时跑 <code>gulp</code> 和 dev server</p>
<h2 id="打开应用"><a href="#打开应用" class="headerlink" title="打开应用"></a>打开应用</h2><p>打开 Chrome 并且跳转到 <code>localhost:8081</code> 你会看到一个事件列表的控制台，在弹出的权限确认菜单中点击允许</p>
<p><img src="/images/build-an-offline-first-data-driven-pwa/1.png" alt="img"></p>
<p>我们使用通知系统来告知用户 app 的后台同步已经更新，试着测试一下页面底部的添加功能</p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>这个小项目的目标是离线保存用户的事件日历。你可以查看一下 <code>app/js/main.js</code> 文件的 <code>loadContentNetworkFirst</code> 方法当前是怎么工作的，首先会请求 server，成功则更新页面，失败会在控制台打印一个信息，目前脱机是无法使用的，接下来我们添加一些方法使它脱机可用。</p>
<h1 id="缓存-app-shell"><a href="#缓存-app-shell" class="headerlink" title="缓存 app shell"></a>缓存 app shell</h1><h2 id="编写-service-worker"><a href="#编写-service-worker" class="headerlink" title="编写 service worker"></a>编写 service worker</h2><p>要想脱机工作，就需要 server worker，现在写一个。</p>
<p>把下面的代码添加到 <code>app/src/sw.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">'workbox-sw.dev.v2.0.0.js'</span>);</span><br><span class="line">importScripts(<span class="string">'workbox-background-sync.dev.v2.0.0.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workboxSW = <span class="keyword">new</span> WorkboxSW();</span><br><span class="line">workboxSW.precache([]);</span><br></pre></td></tr></table></figure>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>在开头我们引入了 <code>workbox-sw</code> 和 <code>workbox-background-sync</code></p>
<ul>
<li><code>workbox-sw</code> 包含了 <code>precache</code> 和向 service worker 添加路由的方法</li>
<li><code>workbox-background-sync</code> 是在 service worker 中后台同步的库，稍后会提到</li>
</ul>
<p><code>precache</code> 方法接收一个文件列表的数组，先用一个空的，下一步我们会用 <code>workbox-build</code> 去计算出这个数组的结果。</p>
<h2 id="构建-service-worker"><a href="#构建-service-worker" class="headerlink" title="构建 service worker"></a>构建 service worker</h2><p>推荐使用 Workbox 的构建模块，比如 <code>workbox-build</code></p>
<p>把下面的代码添加进 <code>project/gulpfile.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'build-sw'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> wbBuild.injectManifest(&#123;</span><br><span class="line">    swSrc: <span class="string">'app/src/sw.js'</span>,</span><br><span class="line">    swDest: <span class="string">'build/service-worker.js'</span>,</span><br><span class="line">    globDirectory: <span class="string">'build'</span>,</span><br><span class="line">    staticFileGlobs: [</span><br><span class="line">      <span class="string">'style/main.css'</span>,</span><br><span class="line">      <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="string">'js/idb-promised.js'</span>,</span><br><span class="line">      <span class="string">'js/main.js'</span>,</span><br><span class="line">      <span class="string">'images/**/*.*'</span>,</span><br><span class="line">      <span class="string">'manifest.json'</span></span><br><span class="line">    ],</span><br><span class="line">    templatedUrls: &#123;</span><br><span class="line">      <span class="string">'/'</span>: [<span class="string">'index.html'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[ERROR] This happened: '</span> + err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在取消一些注释：</p>
<p>gulpfile.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uncomment the line below:</span></span><br><span class="line"><span class="keyword">const</span> wbBuild = <span class="built_in">require</span>(<span class="string">'workbox-build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], cb =&gt; &#123;</span><br><span class="line">  runSequence(</span><br><span class="line">    <span class="string">'copy'</span>,</span><br><span class="line">    <span class="comment">// uncomment the line below:</span></span><br><span class="line">    <span class="string">'build-sw'</span>,</span><br><span class="line">    cb</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>保存修改，因为修改了 gulp，我们得重新跑一下，<code>Ctrl + C</code> 退出当前的进程，重新运行 <code>npm start</code>，会看到 service worker 的文件被生成在了 <code>build/service-worker.js</code></p>
<p>取消 <code>app/index.html</code> 中 service worker 注册代码的注释</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Service Worker registration successful with scope: '</span>,</span><br><span class="line">      registration.scope);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Service Worker registration failed: '</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存修改，刷新浏览器 service worker 就会被安装。<code>Ctrl + C</code> 关闭 dev server，再返回到浏览器中刷新页面，已经可以脱机运行了！</p>
<h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>在这一步中，<code>workbox-build</code> 和 <code>build-sw</code> 任务被合并到我们的 gulp 文件中，我们的构建过程是使用 <code>workbox-build</code> 库来从 <code>swSrc(app/src/sw.js)</code> 中生成 service work 到 <code>swDest(build/service-worker.js)</code>，来自 <code>globDirectory(build)</code> 的 <code>staticFileGlobs</code> 文件被注入到 <code>build/service-worker.js</code> 以供 <code>precache</code> 调用，还有每个文件的修订哈希。templatedUrls 选项告诉 Workbox 我们的站点以 index.html 的内容响应请求。</p>
<p>顺便贴一个 <a href="https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.injectManifest" target="_blank" rel="noopener">injectManifest</a> 的链接</p>
<p>安装生成好的 service worker 缓存 app shell 的资源文件，Workbox 会自动去：</p>
<ul>
<li>为缓存资源设置缓存优先策略，允许应用程序离线加载</li>
<li>service work 更新时，使用修订哈希来更新缓存的文件</li>
</ul>
<h1 id="创建-IndexedDB-数据库"><a href="#创建-IndexedDB-数据库" class="headerlink" title="创建 IndexedDB 数据库"></a>创建 IndexedDB 数据库</h1><p>目前为止还不能离线加载数据，我们接下来创建一个 IndexDB 来保存程序的数据，数据库命名为 <code>dashboardr</code></p>
<p>添加下面代码到 <code>app/js/main.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIndexedDB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">'indexedDB'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">  <span class="keyword">return</span> idb.open(<span class="string">'dashboardr'</span>, <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">upgradeDb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!upgradeDb.objectStoreNames.contains(<span class="string">'events'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventsOS = upgradeDb.createObjectStore(<span class="string">'events'</span>, &#123;<span class="attr">keyPath</span>: <span class="string">'id'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消调用 <code>createIndexedDB</code> 的注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dbPromise = createIndexedDB();</span><br></pre></td></tr></table></figure>
<p>保存文件，重启 server：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>回到浏览器刷新页面，激活 <a href="https://developers.google.com/web/ilt/pwa/tools-for-pwa-developers#chromeupdate" target="_blank" rel="noopener">skipWaiting</a> 并再次刷新页面，在 Chrome 中，你可以在开发者工具中的 <code>Application</code> 面板中选择 <code>Service Workers</code> 点击 <code>skipWaiting</code>，之后使用 <a href="https://developers.google.com/web/ilt/pwa/tools-for-pwa-developers#indexeddb" target="_blank" rel="noopener">开发者工具</a> 检查数据库是否存在。在 Chrome 中你可以在 <code>Application</code> 面板中点击 <code>IndexedDB</code> 选择 <code>dashboardr</code> 查看 <code>events</code> 对象是否存在。</p>
<blockquote>
<p>注意：开发者工具的 IndexedDB UI 可能不会准确的反应你数据库的情况，在 Chrome 中你可以刷新数据库查看，或者重新打开开发者工具</p>
</blockquote>
<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>在上面的代码中，我们创建了一个 dashboardr 数据库，并把他的版本号设置为 <code>1</code> ，然后检查 events 对象是否存在，这个检查是为了避免潜在的错误，我们还给 event 提供了一个唯一的 key path <code>id</code>。</p>
<p>由于我们修改了 <code>app/main.js</code> 文件，gulp 的 <code>watch</code> 任务会自动构建，Workbox 会自动更新修订哈希，然后智能更新缓存中的 <code>main.js</code>。</p>
<h1 id="保存数据到-IndexedDB-中"><a href="#保存数据到-IndexedDB-中" class="headerlink" title="保存数据到 IndexedDB 中"></a>保存数据到 IndexedDB 中</h1><p>现在我们保存数据到刚创建的数据库 <code>dashboardr</code> 中的 <code>event</code> 对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveEventDataLocally</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">'indexedDB'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">  <span class="keyword">return</span> dbPromise.then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'events'</span>, <span class="string">'readwrite'</span>);</span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'events'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(events.map(<span class="function"><span class="params">event</span> =&gt;</span> store.put(event)))</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      tx.abort();</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Events were not added to the store'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新 <code>loadContentNetworkFirst</code> 方法，现在这是完整的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadContentNetworkFirst</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getServerData()</span><br><span class="line">  .then(<span class="function"><span class="params">dataFromNetwork</span> =&gt;</span> &#123;</span><br><span class="line">    updateUI(dataFromNetwork);</span><br><span class="line">    saveEventDataLocally(dataFromNetwork)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setLastUpdated(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      messageDataSaved();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      messageSaveError(); </span><br><span class="line">      <span class="built_in">console</span>.warn(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="comment">// if we can't connect to the server...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Network requests have failed, this is expected if offline'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消注释 <code>addAndPostEvent</code> 中的 <code>saveEventDataLocally</code> 调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAndPostEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  saveEventDataLocally([data]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存文件，刷新页面重新激活 service worker。再次刷新页面，检查一下来自网络的数据是否被保存到 <code>events</code> 中去（你可能需要刷新一下开发者工具中的 <code>IndexedDB</code>）</p>
<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p><code>saveEventDataLocally</code> 接收一个数组并一条条的保存到 IndexedDB 数据库中，我们把 <code>store.put</code> 写在了 <code>Promise.all</code> 中，这样如果某一条更新出错我们就可以终止事务。</p>
<p><code>loadContentNetworkFirst</code> 方法中，一旦收到来自服务器的数据，就会更新 IndexedDB 和页面。然后，数据成功保存时，将存储时间戳，并通知用户数据可供离线使用。</p>
<p>在<code>addAndPostEvent</code> 中调用 <code>saveEventDataLocally</code> 方法保证了添加新的 <code>event</code> 时本地会存有最新的数据。 </p>
<h1 id="从-IndexedDB-中获取数据"><a href="#从-IndexedDB-中获取数据" class="headerlink" title="从 IndexedDB 中获取数据"></a>从 IndexedDB 中获取数据</h1><p>离线的时候，我们就要查询本地缓存的数据。</p>
<p>添加下面的代码到 <code>app/js/main.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocalEventData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">'indexedDB'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">  <span class="keyword">return</span> dbPromise.then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'events'</span>, <span class="string">'readonly'</span>);</span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'events'</span>);</span><br><span class="line">    <span class="keyword">return</span> store.getAll();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新 <code>loadContentNetworkFirst</code> 方法，完整的方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadContentNetworkFirst</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getServerData()</span><br><span class="line">  .then(<span class="function"><span class="params">dataFromNetwork</span> =&gt;</span> &#123;</span><br><span class="line">    updateUI(dataFromNetwork);</span><br><span class="line">    saveEventDataLocally(dataFromNetwork)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setLastUpdated(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      messageDataSaved();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      messageSaveError();</span><br><span class="line">      <span class="built_in">console</span>.warn(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Network requests have failed, this is expected if offline'</span>);</span><br><span class="line">    getLocalEventData()</span><br><span class="line">    .then(<span class="function"><span class="params">offlineData</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!offlineData.length) &#123;</span><br><span class="line">        messageNoData();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        messageOffline();</span><br><span class="line">        updateUI(offlineData); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存文件，刷新浏览器激活更新的 service worker，现在 <code>Ctrl + C</code> 关闭 dev server，返回到浏览器中刷新页面，现在 app 和数据都可以离线加载了！</p>
<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><p><code>loadContentNetworkFirst</code> 被调用的时候如果没有网络连接，<code>getServerData</code> 会被 reject，之后便会进入到 <code>catch</code> 中去，然后 <code>getLocalEventData</code> 会调用本地缓存的数据。有网络连接的话会正常的请求 server 并且 <code>updateUI</code></p>
<h1 id="使用-workbox-background-sync"><a href="#使用-workbox-background-sync" class="headerlink" title="使用 workbox-background-sync"></a>使用 workbox-background-sync</h1><p>我们的 app 已经可以离线保存和浏览数据，现在我们来用 <code>workbox-background-sync</code> 把离线状态下保存的数据同步到服务端去。</p>
<p>把下面的的代码添加到 <code>app/src/sw.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bgQueue = <span class="keyword">new</span> workbox.backgroundSync.QueuePlugin(&#123;</span><br><span class="line">  callbacks: &#123;</span><br><span class="line">    replayDidSucceed: <span class="keyword">async</span>(hash, res) =&gt; &#123;</span><br><span class="line">      self.registration.showNotification(<span class="string">'Background sync demo'</span>, &#123;</span><br><span class="line">        body: <span class="string">'Events have been updated!'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">workboxSW.router.registerRoute(<span class="string">'/api/add'</span>,</span><br><span class="line">  workboxSW.strategies.networkOnly(&#123;<span class="attr">plugins</span>: [bgQueue]&#125;), <span class="string">'POST'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>保存，现在转到命令行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>刷新浏览器，激活更新的 service worker</p>
<p><code>Ctrl + C</code> 把 app 变为离线状态，添加一个 <code>event</code> 确认请求 <code>/api/add</code> 已经被添加进 <code>bgQueueSyncDB</code> 的 <code>QueueStore</code> 对象。</p>
<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>当用户试图在离线情况下添加 <code>event</code> 的时候，<code>workbox-background-sync</code> 会把失败的请求保存为一个离线队列，当用户重新联网 <code>backgroundSync</code> 会重新发送这些请求，甚至都不需要用户打开 app！但是，从联网到重新发请求的这个过程大概需要 5 分钟，下一节我们将会介绍如何在 app 中立即发送这些请求。</p>
<h1 id="重发请求"><a href="#重发请求" class="headerlink" title="重发请求"></a>重发请求</h1><p>因为重发请求会有延迟，所以用户可能回到 app 之后还没有同步数据，所以我们在用户联网的时候立即发送这些请求。</p>
<p>把下面的代码添加到 <code>app/src/sw.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">workboxSW.router.registerRoute(<span class="string">'/api/getAll'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> bgQueue.replayRequests().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'/api/getAll'</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只要用户请求服务端数据（加载或刷新页面时），该路由就会 replay 排队的请求，然后返回最新的服务端数据。这很好，但是用户还是得刷新页面去重新获取数据，我们还有更好的做法。</p>
<p>把下面的代码添加进 <code>app/js/main.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, () =&gt; &#123;</span><br><span class="line">  container.innerHTML = <span class="string">''</span>;</span><br><span class="line">  loadContentNetworkFirst();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>重启 server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>刷新浏览器激活新的 service worker，并再次刷新页面。</p>
<p><code>Ctrl + C</code> 把 app 变为离线状态</p>
<p>添加一条 <code>event</code></p>
<p>重启 server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>这时你应该能立即收到一条数据更新的通知，检查 <code>server-data/events.json</code> 中的数据是否已经更新。</p>
<h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>页面加载的时候会请求 <code>/api/getAll</code>，我们拦截了这个请求，之后主要做了两件事：</p>
<ul>
<li>同步本地的离线数据</li>
<li>重新请求 <code>/api/getAll</code></li>
</ul>
<p>也就是在重新获取服务端的数据之前先同步</p>
<blockquote>
<p>注意：本例中的网络请求设计的非常简单，实际情况下你可能需要考虑更多因素去减少请求的数量。</p>
</blockquote>
<h1 id="添加删除功能"><a href="#添加删除功能" class="headerlink" title="添加删除功能"></a>添加删除功能</h1><p>下面的时间就交给你了，添加一个删除的功能，记得删除 IndexedDB 中的数据。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/01/7-hacks-for-es6-developers/" class="prev">上一篇</a><a href="/2018/01/18/best-practices-for-writing-react-components/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="http://blog.catwen.cn">文鹏飞</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script data-ad-client="ca-pub-9719602535480843" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?508f12c140e77c01b9acd8055bcea5e2";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></body></html>