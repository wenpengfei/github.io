<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 如何避免 await/async 地狱 · 夜色镇歌</title><meta name="description" content="如何避免 await/async 地狱 - 文鹏飞"><meta name="baidu_union_verify" content="72cef2f38e5e048b980ace9972697c53"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://catwen.cn/atom.xml" title="夜色镇歌"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/333241589" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/wenpengfei" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">如何避免 await/async 地狱</h1><div class="post-info">2018年5月10日</div><div class="post-content"><p><img src="/images/how-to-escape-async-await-hell/1.png" alt="img"></p>
<blockquote>
<p>原文地址：<a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c" target="_blank" rel="noopener">How to escape async/await hell</a><br>译文出自：<a href="/2018/05/10/how-to-escape-async-await-hell/" title="夜色镇歌的个人博客">夜色镇歌的个人博客</a></p>
</blockquote>
<p>async/await 把我们从回调地狱中解救了出来，但是如果滥用就会掉进 async/await 地狱。</p>
<p>本文中我会解释一下什么是 async/await 地狱，并会分享几个技巧去避免。</p>
<h2 id="啥是-await-async-地狱"><a href="#啥是-await-async-地狱" class="headerlink" title="啥是 await/async 地狱"></a>啥是 await/async 地狱</h2><p>异步 Javascript 编程中，我们通常会写许多 async 方法，并且使用 <code>await</code> 关键字去等待它，有很多时候下一行的执行并不依赖于上一行，但是我们仍然使用了 <code>await</code> 去等待，所以可能会导致一些性能问题。</p>
<h2 id="一个-await-async-地狱的例子"><a href="#一个-await-async-地狱的例子" class="headerlink" title="一个 await/async 地狱的例子"></a>一个 await/async 地狱的例子</h2><p>如何编写一个订购披萨和饮料的代码？它可能会像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaData = <span class="keyword">await</span> getPizzaData()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> drinkData = <span class="keyword">await</span> getDrinkData()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> chosenPizza = choosePizza()    <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">const</span> chosenDrink = chooseDrink()    <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">await</span> addPizzaToCart(chosenPizza)    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">await</span> addDrinkToCart(chosenDrink)    <span class="comment">// async call</span></span><br><span class="line">  orderItems()    <span class="comment">// async call</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>看起来没什么问题，也能正常工作，但这并不是一个好的实现。先来看下这段代码都做了什么，以便定位问题。</p>
<h2 id="解释下"><a href="#解释下" class="headerlink" title="解释下"></a>解释下</h2><p>我们把代码用 <code>async IIFE</code> 包裹了起来，然后下面这些会依次执行。</p>
<ol>
<li>获取披萨菜单</li>
<li>获取饮料菜单</li>
<li>从披萨菜单中选择披萨</li>
<li>从饮料菜单中选择饮料</li>
<li>把选好的披萨加到购物车</li>
<li>把选好的饮料加到购物车</li>
<li>下单</li>
</ol>
<h2 id="哪里错了？"><a href="#哪里错了？" class="headerlink" title="哪里错了？"></a>哪里错了？</h2><p>正如我刚强调的，这些语句会<strong>依次执行，没有并发</strong>。仔细想一下，为啥我获取饮料菜单之前得先获取披萨菜单？这两份菜单我应该同时去获取。当然，选择披萨之前得先获取披萨菜单，这个规则同样适用于饮料。</p>
<p>所以我们可以得出结论，披萨相关的工作和饮料相关的工作可以并行进行，但涉及披萨相关工作的各个步骤需要按顺序进行（一步接着一步）。</p>
<h2 id="另一个糟糕的例子"><a href="#另一个糟糕的例子" class="headerlink" title="另一个糟糕的例子"></a>另一个糟糕的例子</h2><p>这段代码会获取购物车中的购物项并且发出订购请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">orderItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">await</span> getCartItems()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> noOfItems = items.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; noOfItems; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> sendRequest(items[i])    <span class="comment">// async call</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中 for 循环在下一次迭代之前必须等待上一个 <code>sendRequest()</code> 执行完毕，可我们根本不需要等待，只想尽快的把请求都发送出去然后等待他们都完成。</p>
<p>想必现在你已经了解了什么是 async/await 地狱，以及它对性能的影响是多么的严重。现在我想问你个问题。</p>
<h2 id="如果忘记了-await-关键字呢？"><a href="#如果忘记了-await-关键字呢？" class="headerlink" title="如果忘记了 await 关键字呢？"></a>如果忘记了 await 关键字呢？</h2><p>如果忘记使用 await，async 函数会执行并且返回一个 Promise，你可以稍后再去resolve。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = doSomeAsyncTask()</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// an unresolved promise</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>另一个后果是编译器不知道你想把函数完全执行，所以编译器会退出程序而不完成异步函数，所以还是需要使用 await 关键字</p>
<p>promises 一个有趣的特性就是你可以在一行代码中去得到 Promise ，而在另外一行中去等待并 resolve，这是避免 async/await 地狱的关键之处。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = doSomeAsyncTask()</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">await</span> promise</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// the actual value</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>正如你看到的，<code>doSomeAsyncTask()</code> 方法返回一个 Promise，调用的时候它已经开始执行了，为了得到他的解析值，我们使用了 await 关键字，告诉编译器等待解析完毕再执行下一行。</p>
<h2 id="如何避免-async-await-地狱"><a href="#如何避免-async-await-地狱" class="headerlink" title="如何避免 async/await 地狱"></a>如何避免 async/await 地狱</h2><p>你应该按照这些步骤来避免 async/await 地狱：</p>
<h4 id="找到语句的依赖关系"><a href="#找到语句的依赖关系" class="headerlink" title="找到语句的依赖关系"></a>找到语句的依赖关系</h4><p>第一个例子中，我们选择了一个披萨和一杯饮料。总结一下，选择披萨之前得先获取披萨菜单，加到购物车之前得先选好，这三个步骤都是相互依赖的，必须等待上一个步骤完成后才能进行下一步。</p>
<p>我们选择饮料的时候并不依赖于选择披萨，所以选择披萨和饮料是可以并行执行的。这也是机器能比我们做的更好的一件事。</p>
<h4 id="封装相互依赖的异步方法"><a href="#封装相互依赖的异步方法" class="headerlink" title="封装相互依赖的异步方法"></a>封装相互依赖的异步方法</h4><p>正如你看到的，选择披萨的依赖有获取披萨菜单、选择、添加到购物车。所以我们把这些依赖放在一个异步方法里，饮料同理，这也是为什么我们会有 <code>selectPizza()</code> 和 <code>selectDrink()</code> 两个异步方法。</p>
<h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>我们利用事件循环去非阻塞并行地执行这些异步方法，<strong>通常会用的两个方法就是尽早的返回 <code>Promise</code> 和使用 <code>Promise.all()</code></strong></p>
<p>我们修复一下代码，把这三个方法应用到我们的例子中去。</p>
<h2 id="修改下代码"><a href="#修改下代码" class="headerlink" title="修改下代码"></a>修改下代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">selectPizza</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaData = <span class="keyword">await</span> getPizzaData()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> chosenPizza = choosePizza()    <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">await</span> addPizzaToCart(chosenPizza)    <span class="comment">// async call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">selectDrink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> drinkData = <span class="keyword">await</span> getDrinkData()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> chosenDrink = chooseDrink()    <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">await</span> addDrinkToCart(chosenDrink)    <span class="comment">// async call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaPromise = selectPizza()</span><br><span class="line">  <span class="keyword">const</span> drinkPromise = selectDrink()</span><br><span class="line">  <span class="keyword">await</span> pizzaPromise</span><br><span class="line">  <span class="keyword">await</span> drinkPromise</span><br><span class="line">  orderItems()    <span class="comment">// async call</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although I prefer it this way </span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.all([selectPizza(), selectDrink()]).then(orderItems)   <span class="comment">// async call</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>我们把相互依赖的语句封装在各自的函数里，现在同时去执行 <code>selectPizza()</code> 和 <code>selectDrink()</code></p>
<p>第二个例子中，我们需要处理未知数量的 <code>Promise</code> 。处理这种情况很简单，我们先把 Promises 放进数组，然后使用 <code>Promise.all()</code> 让他们并行执行，之后等待他们全都执行完毕。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">orderItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">await</span> getCartItems()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> noOfItems = items.length</span><br><span class="line">  <span class="keyword">const</span> promises = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; noOfItems; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> orderPromise = sendRequest(items[i])    <span class="comment">// async call</span></span><br><span class="line">    promises.push(orderPromise)    <span class="comment">// sync call</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)    <span class="comment">// async call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although I prefer it this way</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">orderItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">await</span> getCartItems()    <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> promises = items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> sendRequest(item))</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)    <span class="comment">// async call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望本文可以引发你对 async/await 使用的思考，也希望能帮助你提升程序的性能。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/05/25/how-to-use-traefik-as-a-reverse-proxy-for-docker-containers-on-centos-7/" class="prev">上一篇</a><a href="/2018/02/01/7-hacks-for-es6-developers/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://catwen.cn">文鹏飞</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script data-ad-client="ca-pub-9719602535480843" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?508f12c140e77c01b9acd8055bcea5e2";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></body></html>