<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 编写 React 组件的 10 个建议 · 夜色镇歌</title><meta name="description" content="编写 React 组件的 10 个建议 - 文鹏飞"><meta name="baidu_union_verify" content="72cef2f38e5e048b980ace9972697c53"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.catwen.cn/atom.xml" title="夜色镇歌"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/333241589" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/wenpengfei" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">编写 React 组件的 10 个建议</h1><div class="post-info">2019年7月5日</div><div class="post-content"><p><img src="/images/the-10-component-commandments/1.jpg" alt="img"></p>
<p>写一个公用的组件很难，你必须细心地考虑很多问题，比如应该暴露出哪些 <code>props</code>。</p>
<p>本文将简要的介绍 API 设计中的一些最佳实践，以及编写 React 组件的 10 条参考规则。</p>
<h2 id="什么是-API-？"><a href="#什么是-API-？" class="headerlink" title="什么是 API ？"></a>什么是 API ？</h2><p>API （Application Programming Interface）是两段代码或者两个应用如何交互的一个定义或者接口。</p>
<ul>
<li>后端和前端交互使用的是就是 API，可以通过此 API 获取或者操作一组数据</li>
<li>类和调用该类的代码之间的接口也是 API，你可以调用类里面的方法</li>
</ul>
<p>同理，组件定义的 <code>props</code> 也是 API，这是用户与组件交互的方式。</p>
<h2 id="API-设计中的一些最佳实践"><a href="#API-设计中的一些最佳实践" class="headerlink" title="API 设计中的一些最佳实践"></a>API 设计中的一些最佳实践</h2><p>所以，设计一个 API 的时候应该有哪些规则和注意事项？我们做了很多研究并结合实践给出了 4 条 API 设计的最佳实践：</p>
<h4 id="稳定的版本"><a href="#稳定的版本" class="headerlink" title="稳定的版本"></a>稳定的版本</h4><p>最重要的规则之一就是要保持稳定，意思就是要最大限度的减少破坏性的升级，如果你做了破坏性的升级，一定要写一个完整的升级指南，如果可能的话，再提供一些 API 让用户消化升级的过程，使用户升级版本的成本降低。</p>
<p>如果你要发布 API，请使用 <a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>，以便用户可以自由的选择他们需要的版本。</p>
<h4 id="提供错误描述信息"><a href="#提供错误描述信息" class="headerlink" title="提供错误描述信息"></a>提供错误描述信息</h4><p>调用 API 出错的时候，返回给客户端一个详细的错误说明，并且告诉客户端应该如何解决。在没有任何上下文的情况下返回一个 “调用出错” 的错误信息给客户端并不是一个友好的体验。</p>
<h4 id="不要让开发人员迷惑"><a href="#不要让开发人员迷惑" class="headerlink" title="不要让开发人员迷惑"></a>不要让开发人员迷惑</h4><p>开发人员都是很傲娇的，并不想在使用你 API 的时候感到迷惑，换句话说，使你的 API 尽可能的直观，规范。可以通过遵循一些原则和命名规范去实现。</p>
<p>举个例子，你的 API 提供了 boolean 类型的参数，参数命名的时候你在一个地方用 is 做前缀，另外一个地方又用了 has 做前缀，然后其他地方又用了另外一个前缀，这会让开发人员比较迷惑。</p>
<h4 id="暴露出来的-API-尽可能的少"><a href="#暴露出来的-API-尽可能的少" class="headerlink" title="暴露出来的 API 尽可能的少"></a>暴露出来的 API 尽可能的少</h4><p>当然不是说功能多了不好，只是要善用外观模式或者命令模式等去封装一些操作，做到高内聚，API 过多会增加学习成本，一个高内聚的 API 会被认做是一个易于使用的 API。</p>
<h2 id="组件设计的-10-个建议"><a href="#组件设计的-10-个建议" class="headerlink" title="组件设计的 10 个建议"></a>组件设计的 10 个建议</h2><p>上面 4 条规则在 REST APIs 中应用的很好，之前提过的，我们的组件也有它的 API，就是 <code>props</code>，我们该如何定义 <code>props</code> 使它不违反上面的规则呢？下面列出 10 条建议：</p>
<h4 id="写文档"><a href="#写文档" class="headerlink" title="写文档"></a>写文档</h4><p>如果你没有写个组件的使用文档，好吧，使用者可以看你的代码，但这并不是一个好的体验。</p>
<p>有很多写文档的工具，这里推荐三个：</p>
<ul>
<li><a href="https://storybook.js.org/" target="_blank" rel="noopener">Storybook</a></li>
<li><a href="https://react-styleguidist.js.org/" target="_blank" rel="noopener">Styleguidist</a></li>
<li><a href="https://www.docz.site/" target="_blank" rel="noopener">Docz</a></li>
</ul>
<p>不管选用哪个，一定要把所有的 API 使用说明都写出来。</p>
<h4 id="允许上下文语义"><a href="#允许上下文语义" class="headerlink" title="允许上下文语义"></a>允许上下文语义</h4><p>HTML是一种以语义方式结构化信息的语言。然而，我们的大多数组件都是由 <code>&lt;div /&gt;</code> 标签组成的。它在某种程度上是没问题的，因为通用组件不知道我们想要的是 <code>&lt;article /&gt;</code> 或 <code>&lt;section /&gt;</code> 还是 <code>&lt;aside /&gt;</code>，但是这样并不优雅。所以，我们建议允许组件接受一个 <code>prop</code>，它将覆盖正在呈现的 DOM 元素。以下是如何实现它的示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Grid</span>(<span class="params">&#123; as: Element, ...props &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Element className="grid" &#123;...props&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Grid.defaultProps = &#123;</span><br><span class="line">  <span class="keyword">as</span>: <span class="string">'div'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 jsx 中把 <code>as</code> prop 重命名文本地变量 <code>Element</code>，并且把默认值设为 <code>div</code>。</p>
<p>使用 <code>&lt;Grid /&gt;</code> 的时候传递你想要的标签名就好了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Grid <span class="keyword">as</span>=<span class="string">"main"</span>&gt;</span><br><span class="line">      &lt;MoreContent /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Grid&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样在 React 中使用是没有问题的，另外一个经典的例子就是你有一个 <code>&lt;Button /&gt;</code> 组件，想把它渲染成 React Router 的 <code>&lt;Link /&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button <span class="keyword">as</span>=&#123;Link&#125; to=<span class="string">"/profile"</span>&gt;</span><br><span class="line">  Go to Profile</span><br><span class="line">&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="避免使用-boolean-props"><a href="#避免使用-boolean-props" class="headerlink" title="避免使用 boolean props"></a>避免使用 boolean props</h4><p>Boolean props 听起来是个不错的选择，因为你可以不用指定值，看起来非常优雅。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button large&gt;BUY NOW!&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>尽管 Boolean props 看起来非常优雅，但是它只能支持两个值 <code>true</code> or <code>false</code></p>
<p>如果你的组件设计了很多种 boolean 类型的 props 看起来就比较累赘了：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button large small primary disabled secondary&gt;</span><br><span class="line">  WHAT AM I??</span><br><span class="line">&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>换句话说，boolean 通常很难根据需求去扩展。换成字符串枚举是一个更好的选择，它可以扩展为二元值之外的任意值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button variant=<span class="string">"primary"</span> size=<span class="string">"large"</span>&gt;</span><br><span class="line">  I am primarily a large button</span><br><span class="line">&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
<p>不是说 boolean props 一无是处，一些不可能扩展并且只有两个值的 prop 比如 disabled 还是用 boolean 类型。</p>
<h4 id="使用-props-children"><a href="#使用-props-children" class="headerlink" title="使用 props.children"></a>使用 props.children</h4><p>React 有几个特殊的 prop，比如 <code>key</code>，他们有特殊的处理机制，还有一个就是 <code>children</code>。</p>
<p>在开始标签和结束标签中间的内容都会被塞进 <code>props.children</code> props，应该尽可能多的使用它，因为它比一个 <code>content</code> prop，或者一些文本内容需要传递的时候更易使用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableCell content=<span class="string">"Some text"</span> /&gt;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line">&lt;TableCell&gt;Some text&lt;<span class="regexp">/TableCell&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>props.children</code> 有几个好处。首先，它类似于常规 HTML 的使用方式。其次，你可以自由地传递任何你想要的东西，而不是将 <code>leftIcon</code> 和 <code>rightIcon</code> prop 添加到组件中，只需将它们作为 <code>props.children</code> prop 的一部分传递：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableCell&gt;</span><br><span class="line">  &lt;ImportantIcon /&gt; Some text</span><br><span class="line">&lt;<span class="regexp">/TableCell&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可能会说你的组件只会渲染纯文本，不需要其他东西，现在看来可能没问题，但是以后需求不断变化的时候你就会发现 <code>props.children</code> 的好处。</p>
<h4 id="父组件钩子函数"><a href="#父组件钩子函数" class="headerlink" title="父组件钩子函数"></a>父组件钩子函数</h4><p>有时候我们会写一些内部逻辑很复杂的组件，比如 <code>AutoComplete</code> 或者一些图表。</p>
<p>这些类型的组件要渲染的内容通常依赖外部的 API，随着时间的推移，可能还要实现一些特殊的需求</p>
<p>我们如何提供一个单一又标准化的 prop 让调用者去控制或者覆盖组件内部的默认逻辑呢？</p>
<p>解决方案是 <code>state reducers</code> 模式，这里有一篇文章 <a href="https://kentcdodds.com/blog/the-state-reducer-pattern" target="_blank" rel="noopener">post about the concept itself</a></p>
<p>总结下来，<code>state reducer</code> 模式就是让消费者可以访问到组件内部发生的一切事件、状态，从而进行更高级的自定义配置</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCustomDropdown</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stateReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.type === Dropdown.actions.CLOSE) &#123;</span><br><span class="line">      buttonRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Dropdown stateReducer=&#123;stateReducer&#125; &#123;...props&#125; /&gt;</span><br><span class="line">      &lt;Button ref=&#123;buttonRef&#125;&gt;Open&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩散剩余的-props"><a href="#扩散剩余的-props" class="headerlink" title="扩散剩余的 props"></a>扩散剩余的 props</h4><p>当你创建一个新组件的时候，确保剩余的 props 被传递到可以生效的 element 上，不必仅仅是为了向底层组件传递 props 就额外添加一个。可以用 <code>...rest</code> 操作符：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToolTip</span>(<span class="params">&#123; isVisible, ...rest &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isVisible ? &lt;span role="tooltip" &#123;...rest&#125; /&gt; : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给出足够的默认值"><a href="#给出足够的默认值" class="headerlink" title="给出足够的默认值"></a>给出足够的默认值</h4><p>尽量为 props 提供默认值，这样也可以大大减少需要传递 props 的数量，以 <code>onClick</code> 为例，可以提供一个空函数作为默认值，另外可以为字符类型的 prop 提供一个空字符串作为默认值，这样当没有传递 prop 的时候就可以确保处理的是空字符串而不是 undefined 或者 null 等不确定的值 </p>
<h4 id="不要重命名-HTML-的属性"><a href="#不要重命名-HTML-的属性" class="headerlink" title="不要重命名 HTML 的属性"></a>不要重命名 HTML 的属性</h4><p>HTML 标签本身就含有自己的一些属性，就是他自己的 API，为什么不用呢？</p>
<p>就像前面提到过的，减少暴露的 API，为什么要添加一个 screenReaderLabel prop 而不用自身原有的 aria-label API呢？</p>
<p>所以，请不要为了“易用性”而去重复定义，比如添加了 screenReaderLabel prop，然后又传递了一个 aria-label 属性，那么最终显示应该是什么呢？</p>
<p>另外，请不要覆盖 HTML 标签本身的属性，比如 <code>&lt;button /&gt;</code> 元素的 type 属性，可以是 submit（默认）button 或者 reset，然而许多开发者都将它重新定义为其他的含义的props（primary warning info 等），这样就令使用者比较迷惑。</p>
<h4 id="编写-prop-types"><a href="#编写-prop-types" class="headerlink" title="编写 prop types"></a>编写 prop types</h4><p>代码既文档，现在已经有 <code>prop-types</code> 包可用，去使用它。</p>
<p>如果没有传递一些必须的 props，控制台会报错，如果用的是 TypeScript 或者 Flow，那开发体验就更好了。</p>
<h4 id="为开发者设计"><a href="#为开发者设计" class="headerlink" title="为开发者设计"></a>为开发者设计</h4><p>最后，遵循最重要的规则。确保您的 API 和 “组件体验” 针对将使用它的人员或是开发同事进行了优化。</p>
<p>提升开发体验的一个方法就是提供详细的报错信息，或者是在开发模式下在控制台发出警告。</p>
<p>在控制台报错或者报警的时候，如果开发人员也看到了对应错误或者警告的文档链接，会大大提升组件的使用体验。</p>
<p>不必担心过于冗长的错误信息会占用太大空间，况且构建生产环境的时候也不会把这些信息打包进去。</p>
<p>React 本身就是一个非常优秀的类库，当你忘记使用 key 或者拼错了生命周期的名字等等，都会在控制台收到大量详细的错误警告信息。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/11/21/computer-hardware/" class="prev">上一篇</a><a href="/2019/05/25/how-to-use-traefik-as-a-reverse-proxy-for-docker-containers-on-centos-7/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="http://blog.catwen.cn">文鹏飞</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script data-ad-client="ca-pub-9719602535480843" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?508f12c140e77c01b9acd8055bcea5e2";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></body></html>