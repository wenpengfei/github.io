---
title: 我一直都不理解 JavaScript 中的闭包
date: 2018-05-30 10:25:58
tags:
---

![img](/images/i-never-understood-javascript-closures/1.png)

> 原文地址：[I never understood JavaScript closures](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)
> 译文出自：{% post_link i-never-understood-javascript-closures 夜色镇歌的个人博客 %}

我一直都不理解 JavaScript 中的闭包，直到有人这么跟我解释。

正如标题所述，闭包对我来说一直是个谜，我也阅读过大量的文章尝试着去理解，工作当中可能我都没有意识到正在使用它。

在最近的一次谈话中有个人突然敲醒了我，在本文中，我会尝试着也用这种方法来解释。

## 开始之前

有些概念在理解闭包之前很重要，其中之一就是 `执行上下文`，对于执行上下文的基础知识，[这篇文章](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/) 写的非常好，引用一段：

> JavaScript 在执行过程中，它的执行环境非常重要，会被判定为下列的其中之一：
> 全局代码 —— 代码首次执行的默认环境
> 函数代码 —— 每当执行流程进入函数体时
> (.....)
> 让我们把执行上下文这个术语看作当前代码被判定的环境/范围

换句话说，当我们开始执行程序时，我们从全局上执行下文开始。一些变量在全局执行上下文中声明。我们称这些为全局变量。当程序调用函数时会发生什么？会经历几个步骤：

* JavaScript 创建一个新的本地执行上下文
* 该本地执行上下文将具有自己的一组变量，这些变量在该执行上下文中是本地的
* 这个新的执行上下文会被抛到 `执行栈` 上。把执行堆栈看作是跟踪程序执行过程的机制

函数什么时候调用结束？当它遇到 `return` 语句或遇到右括号 `}` 的时候。当一个函数结束时，会经历这几个步骤：

* 本地执行上下文会被弹出执行栈
* 函数把返回值返给 `调用上下文`，调用上下文是调用此函数的执行上下文，它可能是全局执行上下文或另一个本地执行上下文，返回的值可以任何对象。如果该函数没有返回语句，则返回 `undefined`。
* 本地执行上下文被破坏。这个很重要，会被销毁，在本地执行上下文中声明的所有变量都将被清除。他们不再可用。这就是为什么他们被称为局部变量。

## 一个例子

开始讲闭包之前，先看看下面这段简单的代码

```JavaScript
1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
```

为了理解 JavaScript 引擎是如何工作的，我们来详细分析一下

* 第 1 行中，我们在全局上下文中声明了一个变量 `a` 并且给他赋值为 `3`
* 2 ~ 5 行中声明了一个函数，它被存储了起来以备以后调用
* 第 6 行，首先声明了一个变量 `b`。只要有变量声明，它的值就是 `undefined`
* 还是第 6 行，之后调用了函数 `addTwo` 并且赋值给了 `b`
* 首先我们需要调用名称为 `addTwo` 的函数。 JavaScript 将在全局执行上下文内存中查找名为 `addTwo` 找到了，它在第2步（或第2-5行）中定义。并且看到变量 `addTwo` 包含一个函数定义。请注意，变量 `a` 作为参数传递给函数。 JavaScript 在全局执行上下文内存中搜索变量 a，找到它，发现其值为 3，并将数字 3 作为参数传递给该函数。准备执行该函数。
* 现在执行上下文会切换。创建一个新的本地执行上下文，我们将其命名为 `addTwo` 的执行上下文。执行上下文被压入调用堆栈。我们在本地执行环境中做的第一件事是什么？
* 你可能会说，“在本地执行上下文中声明一个新的变量 ret ”。错了，正确的答案是我们需要首先查看函数的参数。在本地执行上下文中声明新的变量 x。并且由于值 3 被作为参数传递，所以变量 x 被分配了数字 3。
* 下一步是：在本地执行上下文中声明新变量 ret。它的值被设置为 undefined。（第3行）
* 还是第 3 行，需要执行加法运算，JavaScript 首先回去寻找变量 x，它会在本地执行上下文中被找到他的值是 3，另外一个值是 2，加法的结果（5）会被赋给 `ret`
* 第 4 行，找到 `ret` 的值 5 返回，函数执行结束
* 第 4-5 行，函数执行结束。本地执行上下文被破坏。变量 `x` 和 `ret` 被回收。他们不再存在。上下文会弹出调用堆栈，并将返回值返回给调用上下文。在这种情况下，调用上下文是全局执行上下文，因为函数 `addTwo` 是在全局执行上下文中调用的
* 第 7 行中，变量 `b` 的值 `5` 被打印在控制台中

## 词法作用域

我们还需要了解此法作用域的一些知识，看下面的例子：

```JavaScript
1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)

```

这个例子中既有本地变量又有全局变量。JavaScript 的一个复杂性在于它如何寻找变量。如果在他自己的 `本地执行上下文` 中没有找到，他回去找调用它的 `调用上下文`，这样一直反复，一直查到 `全局执行上下文`

详细执行过程就不再解释，只需要记住函数可以访问它 `调用上下文` 中定义的变量（val1），叫做 `词法作用域`

## 返回函数的函数

第一个例子中，函数 `addTwo` 返回一个数字，我们还记得，函数可以返回任何东西。我们就来看一个返回函数的例子，这对于理解闭包很重要。

```JavaScript
 1: let val = 7
 2: function createAdder() {
 3:   function addNumbers(a, b) {
 4:     let ret = a + b
 5:     return ret
 6:   }
 7:   return addNumbers
 8: }
 9: let adder = createAdder()
10: let sum = adder(val, 8)
11: console.log('example of function returning a function: ', sum)
```

* 第 1 行，声明了一个全局变量，并且赋值为 7
* 2 ~ 8 行，声明一个函数，同样他被存储了起来为将来调用
* 第 9 行，定义了一个名为 `adder` 的变量，暂时赋值为 `undefined`
* 还是第 9 行，有个函数调用，在全局上下文的内存中去寻找名为 `createAdder` 的变量，找到了，调用它
* 创建一个新的本地执行上下文，随后 JavaScript 引擎将这个新的上下文添加到调用栈，因为没有参数，直接进入到正文
* 还是 3 ~ 6 行，有一个新的函数声明。我们在本地执行上下文中创建一个变量 `addNumbers`。这很重要。`addNumbers` 仅存在于本地执行上下文中。我们把函数存储在名为 `addNumbers` 的本地变量中
* 第 7 行，返回 `addNumbers`，引擎查找名为 `addNumbers` 的变量，发现是一个函数，返回，之后会把这个本地执行上下文删除
* return 之后，本地执行上下文被销毁，`addNumbers` 变量也不复存在 但是 addNumbers 函数被分配给了 `adder`，







